// This file is autogenerated. Do not edit.
// To make changes to this file, edit codegen.rb and/or codegen.erb and run make

use framing::{FrameType, Frame, MethodFrame};
use amqp_error::AMQPResult;

pub trait Method {
    fn decode(method_frame: MethodFrame) -> AMQPResult<Self> where Self: Sized;
    fn encode(&self) -> AMQPResult<Vec<u8>>;
    fn name(&self) -> &'static str;
    fn id(&self) -> u16;
    fn class_id(&self) -> u16;

    fn encode_method_frame(&self) -> AMQPResult<Vec<u8>> {
        let frame = MethodFrame { class_id: self.class_id(), method_id: self.id(), arguments: try!(self.encode()) };
        frame.encode()
    }

    fn to_frame(&self, channel: u16) -> AMQPResult<Frame> {
        Ok(Frame {
            frame_type: FrameType::METHOD,
            channel: channel,
            payload: try!(self.encode_method_frame()),
        })
    }
}

<% classes.each do |klass| %>
#[allow(unused_imports)]
#[allow(missing_copy_implementations)]
pub mod <%= klass["name"] %> {
    use bit_vec::BitVec;
    use table;
    use table::{Table, decode_table, encode_table};
    use protocol;
    use framing::{ContentHeaderFrame, MethodFrame};
    use amqp_error::{AMQPResult, AMQPError};
    use byteorder::{BigEndian, ReadBytesExt, WriteBytesExt};
    use std::io::{Read, Write};
    use codegen_macros::{ArgumentsReader, ArgumentsWriter};

<% if klass["properties"] && klass["properties"].any? -%>
    //properties struct for <%= klass["name"] %>
    #[derive(Debug, Default, Clone)]
    pub struct <%= klass["properties_struct_name"] %> {
<% klass["properties_fields"].join(",\n").split("\n").each do |f| -%>
       <%= f %>
<% end -%>
    }

    impl <%= klass["properties_struct_name"] %> {
        pub fn decode(content_header_frame: ContentHeaderFrame) -> AMQPResult<<%=klass["properties_struct_name"]%>> {
            let reader = &mut &content_header_frame.properties[..];
            let properties_flags = BitVec::from_bytes(&[((content_header_frame.properties_flags >> 8) & 0xff) as u8,
                (content_header_frame.properties_flags & 0xff) as u8]);
<% klass["properties"].each.with_index do |prop, idx| -%>
            let <%= prop["prop_name"] %> = match properties_flags.get(<%= idx %>) {
              Some(flag) if flag => Some(<%=read_type(prop["prop_type"])%>),
              None => return Err(AMQPError::Protocol("Properties flags are not correct".to_owned())),
              _ => None
            };
<% end -%>
            Ok(<%=klass["properties_struct_name"]%> { <%= klass["properties_struct_create"].join(", ") %> })
        }

        pub fn encode(self) -> AMQPResult<Vec<u8>> {
            let mut writer = vec![];
<% klass["properties"].each.with_index do |prop, idx| -%>
              match self.<%= prop["prop_name"] %> {
                  Some(prop) => {
                      let <%= prop["prop_name"] %> =  prop;
                      <%= write_type(prop["prop_name"], prop["prop_type"]) %>
                  }
                  None => {}
              };
<% end -%>
            Ok(writer)
        }

        pub fn flags(&self) -> u16 {
            let mut bits = BitVec::from_elem(16, false);
<% klass["properties"].each.with_index do |prop, idx| -%>
            bits.set(<%= idx %>, self.<%= prop["prop_name"] %>.is_some());
<% end -%>
            let flags : u16 = bits.to_bytes()[0] as u16;
            (flags << 8 | bits.to_bytes()[1] as u16) as u16
        }
    }
<% end -%>

<% klass["methods"].each do |method| -%>
    // Method <%= method["id"] %>:<%=method["name"] %>
    method_struct!(<%=method["method_name"] %>, "<%= klass["name"] %>.<%= method["name"] %>", <%= klass["id"] %>, <%= method["id"] %>,
        <%= method["fields"].map{ |f| "#{f[0]} => #{f[1]}" }.join(",\n") %>
    );

unsafe impl Send for  <%= method["method_name"] %> {}
<% end #methods each-%>
}
<% end #classes each -%>
